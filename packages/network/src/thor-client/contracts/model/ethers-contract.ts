import {
    BaseContract,
    type Contract,
    ContractFactory,
    ContractRunner,
    type Interface
} from 'ethers';
import type { ContractMethodArgs } from 'ethers/src.ts/contract/types';

// eslint-disable-next-line @typescript-eslint/ban-types
type ArgumentTypes<F extends Function> = F extends (...args: infer A) => unknown
    ? A
    : never;

type ElementType<T extends readonly unknown[]> =
    T extends ReadonlyArray<infer ElementType> ? ElementType : never;

type AvailableFunctions<T extends Interface> = ElementType<
    ArgumentTypes<T['getFunction']>
>;

class EthersContractFactory<T extends ContractFactory> extends ContractFactory {
    constructor(private readonly factory: T) {
        super(factory.interface, factory.bytecode);
    }

    public async deploy(
        ...args: ContractMethodArgs<AvailableFunctions<T>>
    ): ReturnType<typeof this.factory.deploy> {
        return this.factory.deploy(...args);
    }
}

class EthersContract<T extends Contract> {
    constructor(private readonly contract: T) {}
}

/* Autogenerated file. Do not edit manually. */
/* eslint-disable */
import type {
    BigNumberish,
    BytesLike,
    Result,
    ContractMethod,
    Listener
} from 'ethers';

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
    Typed,
    ContractTransaction,
    ContractTransactionResponse,
    DeferredTopicFilter,
    EventLog,
    TransactionRequest,
    LogDescription
} from 'ethers';

export interface TypedDeferredTopicFilter<_TCEvent extends TypedContractEvent>
    extends DeferredTopicFilter {}

export interface TypedContractEvent<
    InputTuple extends Array<any> = any,
    OutputTuple extends Array<any> = any,
    OutputObject = any
> {
    (
        ...args: Partial<InputTuple>
    ): TypedDeferredTopicFilter<
        TypedContractEvent<InputTuple, OutputTuple, OutputObject>
    >;

    name: string;
    fragment: EventFragment;

    getFragment(...args: Partial<InputTuple>): EventFragment;
}

type __TypechainAOutputTuple<T> =
    T extends TypedContractEvent<infer _U, infer W> ? W : never;
type __TypechainOutputObject<T> =
    T extends TypedContractEvent<infer _U, infer _W, infer V> ? V : never;

export interface TypedEventLog<TCEvent extends TypedContractEvent>
    extends Omit<EventLog, 'args'> {
    args: __TypechainAOutputTuple<TCEvent> & __TypechainOutputObject<TCEvent>;
}

export interface TypedLogDescription<TCEvent extends TypedContractEvent>
    extends Omit<LogDescription, 'args'> {
    args: __TypechainAOutputTuple<TCEvent> & __TypechainOutputObject<TCEvent>;
}

export type TypedListener<TCEvent extends TypedContractEvent> = (
    ...listenerArg: [
        ...__TypechainAOutputTuple<TCEvent>,
        TypedEventLog<TCEvent>,
        ...undefined[]
    ]
) => void;

export type MinEthersFactory<C, ARGS> = {
    deploy(...a: ARGS[]): Promise<C>;
};

export type GetContractTypeFromFactory<F> =
    F extends MinEthersFactory<infer C, any> ? C : never;
export type GetARGsTypeFromFactory<F> =
    F extends MinEthersFactory<any, any> ? Parameters<F['deploy']> : never;

export type StateMutability = 'nonpayable' | 'payable' | 'view';

export type BaseOverrides = Omit<TransactionRequest, 'to' | 'data'>;
export type NonPayableOverrides = Omit<
    BaseOverrides,
    'value' | 'blockTag' | 'enableCcipRead'
>;
export type PayableOverrides = Omit<
    BaseOverrides,
    'blockTag' | 'enableCcipRead'
>;
export type ViewOverrides = Omit<TransactionRequest, 'to' | 'data'>;
export type Overrides<S extends StateMutability> = S extends 'nonpayable'
    ? NonPayableOverrides
    : S extends 'payable'
      ? PayableOverrides
      : ViewOverrides;

export type PostfixOverrides<A extends Array<any>, S extends StateMutability> =
    | A
    | [...A, Overrides<S>];
export type ContractMethodArgs<
    A extends Array<any>,
    S extends StateMutability
> = PostfixOverrides<{ [I in keyof A]-?: A[I] | Typed }, S>;

export type DefaultReturnType<R> = R extends Array<any> ? R[0] : R;

// export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = R | ContractTransactionResponse> {
export interface TypedContractMethod<
    A extends Array<any> = Array<any>,
    R = any,
    S extends StateMutability = 'payable'
> {
    (
        ...args: ContractMethodArgs<A, S>
    ): S extends 'view'
        ? Promise<DefaultReturnType<R>>
        : Promise<ContractTransactionResponse>;

    name: string;

    fragment: FunctionFragment;

    getFragment(...args: ContractMethodArgs<A, S>): FunctionFragment;

    populateTransaction(
        ...args: ContractMethodArgs<A, S>
    ): Promise<ContractTransaction>;

    staticCall(
        ...args: ContractMethodArgs<A, 'view'>
    ): Promise<DefaultReturnType<R>>;

    send(
        ...args: ContractMethodArgs<A, S>
    ): Promise<ContractTransactionResponse>;

    estimateGas(...args: ContractMethodArgs<A, S>): Promise<bigint>;

    staticCallResult(...args: ContractMethodArgs<A, 'view'>): Promise<R>;
}

export interface SimpleCounterInterface extends Interface {
    getFunction(
        nameOrSignature: 'getCounter' | 'incrementCounter' | 'setCounter'
    ): FunctionFragment;

    getEvent(nameOrSignatureOrTopic: 'CounterIncremented'): EventFragment;

    encodeFunctionData(
        functionFragment: 'getCounter',
        values?: undefined
    ): string;

    encodeFunctionData(
        functionFragment: 'incrementCounter',
        values?: undefined
    ): string;

    encodeFunctionData(
        functionFragment: 'setCounter',
        values: [BigNumberish]
    ): string;

    decodeFunctionResult(
        functionFragment: 'getCounter',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'incrementCounter',
        data: BytesLike
    ): Result;

    decodeFunctionResult(
        functionFragment: 'setCounter',
        data: BytesLike
    ): Result;
}

export namespace CounterIncrementedEvent {
    export type InputTuple = [newValue: BigNumberish];
    export type OutputTuple = [newValue: bigint];

    export interface OutputObject {
        newValue: bigint;
    }

    export type Event = TypedContractEvent<
        InputTuple,
        OutputTuple,
        OutputObject
    >;
    export type Filter = TypedDeferredTopicFilter<Event>;
    export type Log = TypedEventLog<Event>;
    export type LogDescription = TypedLogDescription<Event>;
}

export interface SimpleCounter extends BaseContract {
    connect(runner?: ContractRunner | null): SimpleCounter;

    waitForDeployment(): Promise<this>;

    interface: SimpleCounterInterface;

    queryFilter<TCEvent extends TypedContractEvent>(
        event: TCEvent,
        fromBlockOrBlockhash?: string | number | undefined,
        toBlock?: string | number | undefined
    ): Promise<Array<TypedEventLog<TCEvent>>>;

    queryFilter<TCEvent extends TypedContractEvent>(
        filter: TypedDeferredTopicFilter<TCEvent>,
        fromBlockOrBlockhash?: string | number | undefined,
        toBlock?: string | number | undefined
    ): Promise<Array<TypedEventLog<TCEvent>>>;

    on<TCEvent extends TypedContractEvent>(
        event: TCEvent,
        listener: TypedListener<TCEvent>
    ): Promise<this>;

    on<TCEvent extends TypedContractEvent>(
        filter: TypedDeferredTopicFilter<TCEvent>,
        listener: TypedListener<TCEvent>
    ): Promise<this>;

    once<TCEvent extends TypedContractEvent>(
        event: TCEvent,
        listener: TypedListener<TCEvent>
    ): Promise<this>;

    once<TCEvent extends TypedContractEvent>(
        filter: TypedDeferredTopicFilter<TCEvent>,
        listener: TypedListener<TCEvent>
    ): Promise<this>;

    listeners<TCEvent extends TypedContractEvent>(
        event: TCEvent
    ): Promise<Array<TypedListener<TCEvent>>>;

    listeners(eventName?: string): Promise<Array<Listener>>;

    removeAllListeners<TCEvent extends TypedContractEvent>(
        event?: TCEvent
    ): Promise<this>;

    getCounter: TypedContractMethod<[], [bigint], 'view'>;

    incrementCounter: TypedContractMethod<[], [void], 'nonpayable'>;

    setCounter: TypedContractMethod<
        [amount: BigNumberish],
        [void],
        'nonpayable'
    >;

    getFunction<T extends ContractMethod = ContractMethod>(
        key: string | FunctionFragment
    ): T;

    getFunction(
        nameOrSignature: 'getCounter'
    ): TypedContractMethod<[], [bigint], 'view'>;

    getFunction(
        nameOrSignature: 'incrementCounter'
    ): TypedContractMethod<[], [void], 'nonpayable'>;

    getFunction(
        nameOrSignature: 'setCounter'
    ): TypedContractMethod<[amount: BigNumberish], [void], 'nonpayable'>;

    getEvent(
        key: 'CounterIncremented'
    ): TypedContractEvent<
        CounterIncrementedEvent.InputTuple,
        CounterIncrementedEvent.OutputTuple,
        CounterIncrementedEvent.OutputObject
    >;

    filters: {
        'CounterIncremented(uint256)': TypedContractEvent<
            CounterIncrementedEvent.InputTuple,
            CounterIncrementedEvent.OutputTuple,
            CounterIncrementedEvent.OutputObject
        >;
        CounterIncremented: TypedContractEvent<
            CounterIncrementedEvent.InputTuple,
            CounterIncrementedEvent.OutputTuple,
            CounterIncrementedEvent.OutputObject
        >;
    };
}

const test = new EthersContractFactory<ContractFactory>(new ContractFactory());
